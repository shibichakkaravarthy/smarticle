"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var createElement_1 = require("../utils/createElement");
var lodash_1 = require("lodash");
var Reconciler = require("react-reconciler");
var DEBUG = false;
var DesktopRenderer = Reconciler({
    appendInitialChild: function (parentInstance, child) {
        if (DEBUG)
            console.log("appendInitialChild");
        insertChild(parentInstance, child);
    },
    createInstance: function (type, props) {
        if (DEBUG)
            console.log("createInstance");
        return createElement_1.createElement(type, props);
    },
    createTextInstance: function (text) {
        if (DEBUG)
            console.log("createTextInstance");
        return { text: text, type: "text" };
    },
    finalizeInitialChildren: function () {
        if (DEBUG)
            console.log("finalizeInitialChildren");
        return false;
    },
    getPublicInstance: function (inst) {
        if (DEBUG)
            console.log("getPublicInstance");
        return inst;
    },
    prepareForCommit: function () {
        if (DEBUG)
            console.log("prepareForCommit");
        // noop
    },
    prepareUpdate: function (wordElement, type, oldProps, newProps) {
        if (DEBUG)
            console.log("prepareUpdate");
        var propKeys = lodash_1.uniq(Object.keys(newProps).concat(Object.keys(oldProps)));
        var diff = {};
        for (var _i = 0, propKeys_1 = propKeys; _i < propKeys_1.length; _i++) {
            var key = propKeys_1[_i];
            if (
            //key !== "children" && // children are already handled by react-reconciler
            oldProps[key] !== newProps[key]) {
                diff[key] = newProps[key];
            }
        }
        // console.log(oldProps, newProps);
        // console.log("DIFF", diff);
        return diff;
    },
    resetAfterCommit: function (hostContext) {
        if (DEBUG)
            console.log("resetAfterCommit");
        hostContext.afterCommit(hostContext);
    },
    resetTextContent: function () {
        if (DEBUG)
            console.log("resetTextContent");
        // noop
    },
    getRootHostContext: function () {
        if (DEBUG)
            console.log("getRootHostContext");
        return {};
    },
    getChildHostContext: function () {
        if (DEBUG)
            console.log("getChildHostContext");
        return {};
    },
    shouldSetTextContent: function () {
        if (DEBUG)
            console.log("shouldSetTextContent");
        return false;
    },
    now: function () { },
    useSyncScheduling: true,
    // MUTATION
    appendChild: function (parentInstance, child) {
        if (DEBUG)
            console.log("appendChild");
        insertChild(parentInstance, child);
    },
    appendChildToContainer: function (parentInstance, child) {
        if (DEBUG)
            console.log("appendChildToContainer");
        insertChild(parentInstance, child);
    },
    removeChild: function (parentInstance, child) {
        if (DEBUG)
            console.log("removeChild");
        removeChild(parentInstance, child);
    },
    removeChildFromContainer: function (parentInstance, child) {
        if (DEBUG)
            console.log("removeChildFromContainer");
        removeChild(parentInstance, child);
    },
    insertBefore: function (parentInstance, child, beforeChild) {
        if (DEBUG)
            console.log("insertBefore");
        insertChild(parentInstance, child, beforeChild);
    },
    commitUpdate: function (instance, updatePayload) {
        if (DEBUG)
            console.log("commitUpdate");
        //console.log("UPDATE", instance, updatePayload);
        instance.updateProps(updatePayload);
    },
    commitMount: function () {
        if (DEBUG)
            console.log("commitMount");
        // noop
    },
    commitTextUpdate: function (textInstance, oldText, newText) {
        if (DEBUG)
            console.log("commitTextUpdate");
        //console.log("TEXT UPDATE", newText);
        textInstance.text = newText;
        textInstance.parent.updateText();
    },
    supportsMutation: true,
    supportsPersistence: false
});
var removeChild = function (container, child) {
    //console.log("REMOVE", child);
    if (container.removeChild) {
        container.removeChild(child);
    }
    else {
        throw new Error("Can't remove child from " + container.constructor.name);
    }
};
var insertChild = function (container, child, beforeChild) {
    var _a, _b, _c, _d;
    var operation = beforeChild ? "insertChild" : "appendChild";
    var params = beforeChild ? [child, beforeChild] : [child];
    if (container[operation]) {
        setParent(container, child);
        //@ts-ignore
        container[operation].apply(container, params);
        (_d = (_b = (_a = child) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : (_c = _b).show) === null || _d === void 0 ? void 0 : _d.call(_c); // TODO: Should this be here?
    }
    else {
        throw new Error("Can't append child to " + container.constructor.name);
    }
};
var setParent = function (container, child) {
    if (typeof child == "object")
        child.parent = container;
};
exports.default = DesktopRenderer;
